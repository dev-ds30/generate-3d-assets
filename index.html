<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Random 3D Asset Generator</title>
  <meta name="description" content="Generate random 3D assets with 31 shapes, 16 textures, and 6 materials. Download as OBJ, JSON, or GLTF.">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow-x: hidden;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  
  <script type="text/babel">
    const { useEffect, useRef, useState } = React;

    const Random3DGenerator = () => {
      const containerRef = useRef(null);
      const sceneRef = useRef(null);
      const cameraRef = useRef(null);
      const rendererRef = useRef(null);
      const meshRef = useRef(null);
      const [assetType, setAssetType] = useState('');
      const [textureType, setTextureType] = useState('');
      const [materialType, setMaterialType] = useState('');
      const [geometryData, setGeometryData] = useState(null);

      const createParametricShape = (type) => {
        const positions = [];
        const indices = [];
        const uvs = [];
        
        const segments = 64;
        
        switch(type) {
          case 'mobius-strip':
            for (let i = 0; i <= segments; i++) {
              for (let j = 0; j <= segments; j++) {
                const u = (i / segments) * 2 * Math.PI;
                const v = (j / segments - 0.5) * 0.5;
                
                const x = (1 + v * Math.cos(u / 2)) * Math.cos(u);
                const y = (1 + v * Math.cos(u / 2)) * Math.sin(u);
                const z = v * Math.sin(u / 2);
                
                positions.push(x, y, z);
                uvs.push(i / segments, j / segments);
              }
            }
            break;
          case 'klein-bottle':
            for (let i = 0; i <= segments; i++) {
              for (let j = 0; j <= segments; j++) {
                const u = (i / segments) * 2 * Math.PI;
                const v = (j / segments) * 2 * Math.PI;
                
                const r = 2;
                const x = (r + Math.cos(u / 2) * Math.sin(v) - Math.sin(u / 2) * Math.sin(2 * v)) * Math.cos(u);
                const y = (r + Math.cos(u / 2) * Math.sin(v) - Math.sin(u / 2) * Math.sin(2 * v)) * Math.sin(u);
                const z = Math.sin(u / 2) * Math.sin(v) + Math.cos(u / 2) * Math.sin(2 * v);
                
                positions.push(x * 0.3, y * 0.3, z * 0.3);
                uvs.push(i / segments, j / segments);
              }
            }
            break;
          case 'shell':
            for (let i = 0; i <= segments; i++) {
              for (let j = 0; j <= segments; j++) {
                const u = (i / segments) * 2 * Math.PI;
                const v = (j / segments) * 2 * Math.PI;
                
                const x = Math.pow(Math.E, v / (6 * Math.PI)) * Math.cos(v) * (1 + Math.cos(u));
                const y = Math.pow(Math.E, v / (6 * Math.PI)) * Math.sin(v) * (1 + Math.cos(u));
                const z = Math.pow(Math.E, v / (6 * Math.PI)) * Math.sin(u);
                
                positions.push(x * 0.5, y * 0.5, z * 0.5);
                uvs.push(i / segments, j / segments);
              }
            }
            break;
        }
        
        for (let i = 0; i < segments; i++) {
          for (let j = 0; j < segments; j++) {
            const a = i * (segments + 1) + j;
            const b = a + segments + 1;
            indices.push(a, b, a + 1);
            indices.push(b, b + 1, a + 1);
          }
        }
        
        const geometry = new THREE.BufferGeometry();
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
        geometry.setIndex(indices);
        geometry.computeVertexNormals();
        
        return geometry;
      };

      const createTexture = (type, color) => {
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 512;
        const ctx = canvas.getContext('2d');
        
        switch(type) {
          case 'checkerboard':
            const size = 64;
            for (let i = 0; i < 8; i++) {
              for (let j = 0; j < 8; j++) {
                ctx.fillStyle = (i + j) % 2 === 0 ? `#${color.toString(16)}` : '#ffffff';
                ctx.fillRect(i * size, j * size, size, size);
              }
            }
            break;
          case 'stripes':
            for (let i = 0; i < 512; i += 64) {
              ctx.fillStyle = i % 128 === 0 ? `#${color.toString(16)}` : '#ffffff';
              ctx.fillRect(i, 0, 64, 512);
            }
            break;
          case 'dots':
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = `#${color.toString(16)}`;
            for (let i = 32; i < 512; i += 64) {
              for (let j = 32; j < 512; j += 64) {
                ctx.beginPath();
                ctx.arc(i, j, 20, 0, Math.PI * 2);
                ctx.fill();
              }
            }
            break;
          case 'gradient':
            const gradient = ctx.createLinearGradient(0, 0, 512, 512);
            gradient.addColorStop(0, `#${color.toString(16)}`);
            gradient.addColorStop(1, '#ffffff');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 512, 512);
            break;
          case 'noise':
            const imageData = ctx.createImageData(512, 512);
            for (let i = 0; i < imageData.data.length; i += 4) {
              const noise = Math.random() * 255;
              imageData.data[i] = noise;
              imageData.data[i + 1] = noise;
              imageData.data[i + 2] = noise;
              imageData.data[i + 3] = 255;
            }
            ctx.putImageData(imageData, 0, 0);
            break;
          case 'waves':
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = `#${color.toString(16)}`;
            ctx.lineWidth = 4;
            for (let y = 0; y < 512; y += 32) {
              ctx.beginPath();
              for (let x = 0; x < 512; x++) {
                const wave = Math.sin(x * 0.02) * 10;
                ctx.lineTo(x, y + wave);
              }
              ctx.stroke();
            }
            break;
          case 'hexagons':
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = `#${color.toString(16)}`;
            const hexSize = 30;
            for (let y = 0; y < 512; y += hexSize * 1.5) {
              for (let x = 0; x < 512; x += hexSize * Math.sqrt(3)) {
                const offsetX = (y / (hexSize * 1.5)) % 2 === 0 ? 0 : hexSize * Math.sqrt(3) / 2;
                ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                  const angle = (Math.PI / 3) * i;
                  const hx = x + offsetX + hexSize * Math.cos(angle);
                  const hy = y + hexSize * Math.sin(angle);
                  if (i === 0) ctx.moveTo(hx, hy);
                  else ctx.lineTo(hx, hy);
                }
                ctx.closePath();
                ctx.fill();
              }
            }
            break;
          case 'brick':
            ctx.fillStyle = `#${color.toString(16)}`;
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 3;
            const brickH = 64;
            const brickW = 128;
            for (let y = 0; y < 512; y += brickH) {
              for (let x = 0; x < 512; x += brickW) {
                const offset = (y / brickH) % 2 === 0 ? 0 : brickW / 2;
                ctx.strokeRect(x + offset, y, brickW, brickH);
              }
            }
            break;
          case 'circuit':
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = `#${color.toString(16)}`;
            ctx.lineWidth = 2;
            for (let i = 0; i < 50; i++) {
              ctx.beginPath();
              ctx.moveTo(Math.random() * 512, Math.random() * 512);
              for (let j = 0; j < 5; j++) {
                const x = Math.random() * 512;
                const y = Math.random() * 512;
                Math.random() > 0.5 ? ctx.lineTo(x, y) : ctx.moveTo(x, y);
              }
              ctx.stroke();
            }
            ctx.fillStyle = `#${color.toString(16)}`;
            for (let i = 0; i < 20; i++) {
              ctx.beginPath();
              ctx.arc(Math.random() * 512, Math.random() * 512, 5, 0, Math.PI * 2);
              ctx.fill();
            }
            break;
          case 'camouflage':
            const camo = ['#3d5a3d', '#5c7a3d', '#8b9d5f', '#4a5d3f'];
            for (let i = 0; i < 100; i++) {
              ctx.fillStyle = camo[Math.floor(Math.random() * camo.length)];
              ctx.beginPath();
              ctx.ellipse(
                Math.random() * 512,
                Math.random() * 512,
                Math.random() * 80 + 20,
                Math.random() * 80 + 20,
                Math.random() * Math.PI,
                0,
                Math.PI * 2
              );
              ctx.fill();
            }
            break;
          case 'carbon-fiber':
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 512, 512);
            for (let y = 0; y < 512; y += 4) {
              for (let x = 0; x < 512; x += 4) {
                const shade = Math.random() * 50;
                ctx.fillStyle = `rgb(${shade}, ${shade}, ${shade})`;
                ctx.fillRect(x, y, 4, 4);
              }
            }
            break;
          case 'wood':
            const gradient2 = ctx.createLinearGradient(0, 0, 512, 0);
            gradient2.addColorStop(0, '#8B4513');
            gradient2.addColorStop(0.5, '#A0522D');
            gradient2.addColorStop(1, '#8B4513');
            ctx.fillStyle = gradient2;
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = 'rgba(139, 69, 19, 0.3)';
            for (let i = 0; i < 20; i++) {
              ctx.lineWidth = Math.random() * 3 + 1;
              ctx.beginPath();
              const startY = Math.random() * 512;
              ctx.moveTo(0, startY);
              for (let x = 0; x < 512; x += 50) {
                ctx.quadraticCurveTo(x, startY + Math.random() * 20 - 10, x + 50, startY);
              }
              ctx.stroke();
            }
            break;
          case 'marble':
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, 0, 512, 512);
            ctx.strokeStyle = `#${color.toString(16)}`;
            for (let i = 0; i < 30; i++) {
              ctx.lineWidth = Math.random() * 5 + 1;
              ctx.globalAlpha = Math.random() * 0.3 + 0.1;
              ctx.beginPath();
              ctx.moveTo(Math.random() * 512, 0);
              for (let y = 0; y < 512; y += 20) {
                ctx.lineTo(Math.random() * 512, y);
              }
              ctx.stroke();
            }
            ctx.globalAlpha = 1;
            break;
          case 'scales':
            ctx.fillStyle = `#${color.toString(16)}`;
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#ffffff';
            const scaleSize = 40;
            for (let y = 0; y < 512; y += scaleSize / 2) {
              for (let x = 0; x < 512; x += scaleSize) {
                const offsetX = (y / (scaleSize / 2)) % 2 === 0 ? 0 : scaleSize / 2;
                ctx.beginPath();
                ctx.arc(x + offsetX, y, scaleSize / 2, 0, Math.PI, true);
                ctx.fill();
              }
            }
            break;
          case 'stars':
            ctx.fillStyle = '#000033';
            ctx.fillRect(0, 0, 512, 512);
            ctx.fillStyle = '#ffffff';
            for (let i = 0; i < 200; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 2;
              ctx.fillRect(x, y, size, size);
            }
            ctx.fillStyle = `#${color.toString(16)}`;
            for (let i = 0; i < 20; i++) {
              const x = Math.random() * 512;
              const y = Math.random() * 512;
              const size = Math.random() * 3 + 2;
              ctx.fillRect(x, y, size, size);
            }
            break;
          default:
            ctx.fillStyle = `#${color.toString(16)}`;
            ctx.fillRect(0, 0, 512, 512);
        }
        
        const texture = new THREE.CanvasTexture(canvas);
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        return texture;
      };

      const generateRandomAsset = () => {
        const types = [
          'cube', 'sphere', 'cylinder', 'torus', 'cone', 
          'octahedron', 'dodecahedron', 'icosahedron', 'tetrahedron',
          'torusKnot', 'ring', 'plane', 'pyramid', 'prism',
          'star', 'diamond', 'rounded-cube', 'capsule', 'egg',
          'mobius-strip', 'klein-bottle', 'shell', 'double-torus',
          'twisted-box', 'spiked-sphere', 'gear', 'spring',
          'crystal', 'polyhedron', 'hyperboloid'
        ];
        const randomType = types[Math.floor(Math.random() * types.length)];
        
        const colors = [
          0xff6b6b, 0x4ecdc4, 0x45b7d1, 0xf7b731, 0x5f27cd, 
          0x00d2d3, 0xff9ff3, 0xfeca57, 0x48dbfb, 0xff6348,
          0x1dd1a1, 0x10ac84, 0xee5a6f, 0x833471, 0x2e86de,
          0xa29bfe, 0xfd79a8, 0xfdcb6e, 0x00b894, 0x6c5ce7,
          0xff7675, 0x74b9ff, 0x55efc4, 0xffeaa7, 0xdfe6e9
        ];
        const randomColor = colors[Math.floor(Math.random() * colors.length)];
        
        const textureTypes = [
          'solid', 'checkerboard', 'stripes', 'dots', 'gradient', 'noise', 'waves',
          'hexagons', 'brick', 'circuit', 'camouflage', 'carbon-fiber', 
          'wood', 'marble', 'scales', 'stars'
        ];
        const randomTexture = textureTypes[Math.floor(Math.random() * textureTypes.length)];
        
        const materialTypes = ['standard', 'metallic', 'glossy', 'glass', 'emissive', 'wireframe'];
        const randomMaterial = materialTypes[Math.floor(Math.random() * materialTypes.length)];
        
        let geometry;
        let params = {};
        
        switch(randomType) {
          case 'cube':
            const size = Math.random() * 2 + 1;
            geometry = new THREE.BoxGeometry(size, size, size);
            params = { type: 'cube', size };
            break;
          case 'sphere':
            const radius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.SphereGeometry(radius, 32, 32);
            params = { type: 'sphere', radius };
            break;
          case 'cylinder':
            const cylRadius = Math.random() * 1 + 0.5;
            const height = Math.random() * 2 + 1;
            geometry = new THREE.CylinderGeometry(cylRadius, cylRadius, height, 32);
            params = { type: 'cylinder', radius: cylRadius, height };
            break;
          case 'torus':
            const torusRadius = Math.random() * 1 + 0.5;
            const tube = Math.random() * 0.5 + 0.2;
            geometry = new THREE.TorusGeometry(torusRadius, tube, 16, 100);
            params = { type: 'torus', radius: torusRadius, tube };
            break;
          case 'cone':
            const coneRadius = Math.random() * 1 + 0.5;
            const coneHeight = Math.random() * 2 + 1;
            geometry = new THREE.ConeGeometry(coneRadius, coneHeight, 32);
            params = { type: 'cone', radius: coneRadius, height: coneHeight };
            break;
          case 'octahedron':
            const octRadius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.OctahedronGeometry(octRadius);
            params = { type: 'octahedron', radius: octRadius };
            break;
          case 'dodecahedron':
            const dodRadius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.DodecahedronGeometry(dodRadius);
            params = { type: 'dodecahedron', radius: dodRadius };
            break;
          case 'icosahedron':
            const icoRadius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.IcosahedronGeometry(icoRadius);
            params = { type: 'icosahedron', radius: icoRadius };
            break;
          case 'tetrahedron':
            const tetRadius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.TetrahedronGeometry(tetRadius);
            params = { type: 'tetrahedron', radius: tetRadius };
            break;
          case 'torusKnot':
            const knotRadius = Math.random() * 1 + 0.5;
            const knotTube = Math.random() * 0.3 + 0.1;
            geometry = new THREE.TorusKnotGeometry(knotRadius, knotTube, 100, 16);
            params = { type: 'torusKnot', radius: knotRadius, tube: knotTube };
            break;
          case 'ring':
            const innerRadius = Math.random() * 0.5 + 0.3;
            const outerRadius = innerRadius + Math.random() * 1 + 0.5;
            geometry = new THREE.RingGeometry(innerRadius, outerRadius, 32);
            params = { type: 'ring', innerRadius, outerRadius };
            break;
          case 'plane':
            const width = Math.random() * 2 + 1;
            const planeHeight = Math.random() * 2 + 1;
            geometry = new THREE.PlaneGeometry(width, planeHeight, 10, 10);
            params = { type: 'plane', width, height: planeHeight };
            break;
          case 'pyramid':
            const pyrRadius = Math.random() * 1 + 0.5;
            const pyrHeight = Math.random() * 2 + 1;
            geometry = new THREE.ConeGeometry(pyrRadius, pyrHeight, 4);
            params = { type: 'pyramid', radius: pyrRadius, height: pyrHeight };
            break;
          case 'prism':
            const prismRadius = Math.random() * 1 + 0.5;
            const prismHeight = Math.random() * 2 + 1;
            geometry = new THREE.CylinderGeometry(prismRadius, prismRadius, prismHeight, 6);
            params = { type: 'prism', radius: prismRadius, height: prismHeight };
            break;
          case 'star':
            const starRadius = Math.random() * 1.5 + 0.5;
            geometry = new THREE.DodecahedronGeometry(starRadius, 1);
            params = { type: 'star', radius: starRadius };
            break;
          case 'diamond':
            const diamondRadius = Math.random() * 1 + 0.5;
            geometry = new THREE.OctahedronGeometry(diamondRadius, 2);
            params = { type: 'diamond', radius: diamondRadius };
            break;
          case 'rounded-cube':
            const rcSize = Math.random() * 2 + 1;
            geometry = new THREE.BoxGeometry(rcSize, rcSize, rcSize, 4, 4, 4);
            params = { type: 'rounded-cube', size: rcSize };
            break;
          case 'capsule':
            const capRadius = Math.random() * 0.5 + 0.3;
            const capHeight = Math.random() * 2 + 1;
            geometry = new THREE.CylinderGeometry(capRadius, capRadius, capHeight, 32);
            params = { type: 'capsule', radius: capRadius, height: capHeight };
            break;
          case 'egg':
            const eggRadius = Math.random() * 1 + 0.5;
            geometry = new THREE.SphereGeometry(eggRadius, 32, 32);
            geometry.scale(1, 1.3, 1);
            params = { type: 'egg', radius: eggRadius };
            break;
          case 'mobius-strip':
            geometry = createParametricShape('mobius-strip');
            params = { type: 'mobius-strip' };
            break;
          case 'klein-bottle':
            geometry = createParametricShape('klein-bottle');
            params = { type: 'klein-bottle' };
            break;
          case 'shell':
            geometry = createParametricShape('shell');
            params = { type: 'shell' };
            break;
          case 'double-torus':
            const dt1 = new THREE.TorusGeometry(0.8, 0.3, 16, 100);
            const dt2 = new THREE.TorusGeometry(0.8, 0.3, 16, 100);
            dt2.translate(0.8, 0, 0);
            geometry = new THREE.BufferGeometry();
            const dtPositions = [];
            const dt1Pos = dt1.attributes.position.array;
            const dt2Pos = dt2.attributes.position.array;
            for (let i = 0; i < dt1Pos.length; i++) dtPositions.push(dt1Pos[i]);
            for (let i = 0; i < dt2Pos.length; i++) dtPositions.push(dt2Pos[i]);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(dtPositions, 3));
            params = { type: 'double-torus' };
            break;
          case 'twisted-box':
            const tbSize = Math.random() * 2 + 1;
            geometry = new THREE.BoxGeometry(tbSize, tbSize, tbSize, 10, 10, 10);
            const tbPos = geometry.attributes.position;
            for (let i = 0; i < tbPos.count; i++) {
              const y = tbPos.getY(i);
              const angle = y * 0.5;
              const x = tbPos.getX(i);
              const z = tbPos.getZ(i);
              tbPos.setX(i, x * Math.cos(angle) - z * Math.sin(angle));
              tbPos.setZ(i, x * Math.sin(angle) + z * Math.cos(angle));
            }
            params = { type: 'twisted-box', size: tbSize };
            break;
          case 'spiked-sphere':
            const ssRadius = Math.random() * 1 + 0.5;
            geometry = new THREE.IcosahedronGeometry(ssRadius, 1);
            const ssPos = geometry.attributes.position;
            for (let i = 0; i < ssPos.count; i++) {
              const spike = Math.random() * 0.5 + 1;
              ssPos.setX(i, ssPos.getX(i) * spike);
              ssPos.setY(i, ssPos.getY(i) * spike);
              ssPos.setZ(i, ssPos.getZ(i) * spike);
            }
            params = { type: 'spiked-sphere', radius: ssRadius };
            break;
          case 'gear':
            const gearRadius = Math.random() * 1 + 0.5;
            geometry = new THREE.CylinderGeometry(gearRadius, gearRadius, 0.5, 16);
            params = { type: 'gear', radius: gearRadius };
            break;
          case 'spring':
            const springRadius = Math.random() * 0.5 + 0.3;
            geometry = new THREE.TorusGeometry(springRadius, 0.1, 8, 100);
            params = { type: 'spring', radius: springRadius };
            break;
          case 'crystal':
            const crystalSize = Math.random() * 1.5 + 0.5;
            geometry = new THREE.OctahedronGeometry(crystalSize, 0);
            geometry.scale(1, 2, 1);
            params = { type: 'crystal', size: crystalSize };
            break;
          case 'polyhedron':
            const polyRadius = Math.random() * 1.5 + 0.5;
            const sides = Math.floor(Math.random() * 8) + 8;
            geometry = new THREE.CylinderGeometry(polyRadius, polyRadius, 1, sides);
            params = { type: 'polyhedron', radius: polyRadius, sides };
            break;
          case 'hyperboloid':
            const hypRadius = Math.random() * 1 + 0.5;
            geometry = new THREE.CylinderGeometry(hypRadius, hypRadius * 1.5, 2, 32);
            const hypPos = geometry.attributes.position;
            for (let i = 0; i < hypPos.count; i++) {
              const y = hypPos.getY(i);
              const scale = 1 - Math.abs(y) * 0.3;
              hypPos.setX(i, hypPos.getX(i) * scale);
              hypPos.setZ(i, hypPos.getZ(i) * scale);
            }
            params = { type: 'hyperboloid', radius: hypRadius };
            break;
        }
        
        let material;
        
        switch(randomMaterial) {
          case 'metallic':
            material = new THREE.MeshStandardMaterial({
              color: randomColor,
              metalness: 0.9,
              roughness: 0.1
            });
            break;
          case 'glossy':
            material = new THREE.MeshPhongMaterial({
              color: randomColor,
              shininess: 150,
